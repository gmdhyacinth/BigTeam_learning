# 插件化

我之前在暴风工作，当时由于业务需要，大量的需要和第三方app换量，为了提升成功率，所以做了插件化。当时主要有两种，DynamicLoadApk和360出的DroidPlugin。两种方式在两个项目分别用了。下面说一下这两种。

### 1、DynamicLoadApk 

​     Github地址:<https://github.com/Qihoo360/DroidPlugin>

这种就是代理模式了，首先在你自己的manifest中定义代理Activity类，根据插件需要，使用代理Activity走生命周期，并调用插件Activity的声明周期方法来完成工作，代理Activity是一个标准的Activity组件，具有生命周期和上下文环境（ContextWrapper和ContextCompl），但是它自身没有承担什么业务逻辑；而插件Activity其实只是一个普通的Java对象，它没有上下文环境，但是却能正常执行业务逻辑的代码。代理Activity和不同的插件Activity配合起来，就能完成不同的业务逻辑了。

缺点是为了实现代理功能，插件apk必须实现DLBasePluginActivity，属于侵入式的，维护成本有点高，需要第三方插件配合修改，而且目前暂不支持Service、BroadcastReceiver等需要注册才能使用的组件，但广播可以采用代码动态注册。还有个问题就是签名问题，要是宿主和插件签名不一致，sdk支付会有问题。分享的话，可以做代理

优点是宿主和插件可以频繁交互，启动时间短。

### 2.DroidPlugin

​	Github地址:<https://github.com/Qihoo360/DroidPlugin>

​     当时15年，遇到这个插件的时候，感觉非常的神奇，居然这莫牛逼，于是赶紧研究，准备接入。

​     这个框架最大的好处是，无需插件方配合，直接给apk就可以安装运行，用户无感知。当时我们的app略大，第一次启动略慢，而且4大组件全支持。

​     因为是开源的，所以可以研究代码。发现他内部用的是hook机制，为了做这个事，在宿主机的Manifest声明了可能用到的各种情况的Activity，1个service和1个content provider预注册占坑，广播全部用动态注册。

在启动插件页面的时候，hook了AMS，拦截并替换成代理页面，顺利通过了检查，等到准备启动页面的时候，再替换回来，蒙混过关，典型的枪手。



详细的介绍，我见已经有人写了，我就不献丑了，见文后链接，已经分析的很具体了

流程图，引用别人的图：

![流程图](..\images\droidplugin.jpg)



#### 加载插件中so：

 当我们调用`System.loadLibrary("so_name")`方法时，会执行loader.findLibrary(libraryName),主要作用就是根据文件名查找so的绝对路径，如果我们要加载插件so，必须协助他找到正确的路径

 1）通过`DexClassLoader`去load插件apk，`DexClassLoader`构造方法可以传入`libraryPath`，该参数就是允许你指定so加载路径

2）在 `PathClassLoader` 和 `BootClassLoader` 之间插入一个 自定义的`MyClassLoader`，然后在`MyClassLoader`中重写`findLibrary`方法

3）通过反射去调用`makePathElements`方法，将`librarySearchPath`路径传入，从而获得新的`nativeLibraryPathElements`数组，然后将新旧合并。

#### 插件化实现的思想

>  类加载：
>
>  Android中常用的有两种类加载器，DexClassLoader和PathClassLoader，它们都继承于BaseDexClassLoader。
>
>  区别在于调用父类构造器时，DexClassLoader多传了一个optimizedDirectory参数，这个目录必须是内部存储路径，用来缓存系统创建的Dex文件。而PathClassLoader该参数为null，只能加载内部存储目录的Dex文件。所以我们可以用DexClassLoader去加载外部的apk。
>
>  双亲委托机制：
>
>  ClassLoader加载类时，先查看自身是否已经加载过该类，如果没有加载过会首先让父加载器去加载，如果父加载器无法加载该类时才会调用自身的findClass方法加载，该机制很大程度上避免了类的重复加载。
>  插件化设计内容稍多，具体可以参考下面的文章。
>
>  https://www.jianshu.com/p/0a2501328e0e
>
>  https://www.jianshu.com/p/590721df1699



底部见引用的文章链接，支持原创！！

参考文章：

1）[DroidPlugin源码分析（四）Activity预注册占坑](https://blog.csdn.net/hejjunlin/article/details/52258434)

2）[Hook机制之AMS&PMS](http://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook)

3 ) [Hook机制之动态代理](http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/)

4 ) [Hook机制之Binder Hook](http://weishu.me/2016/02/16/understand-plugin-framework-binder-hook/)

5 ) [插件加载机制](http://weishu.me/2016/04/05/understand-plugin-framework-classloader/)

6 ) [Activity生命周期管理](http://weishu.me/2016/03/21/understand-plugin-framework-activity-management/)

7）[实战插件化](https://www.jianshu.com/p/cd777bb769c6)

8）[插件化中加载so库解决方案](https://www.jianshu.com/p/a4a6ed83483b)