# Java基础

[Toc]

#### 什么是重载 & 什么是重写 & 区别

> 重载：(Overload)在同一个类中，同名的方法如果有不同的参数列表（**参数类型不同、参数个数不同甚至是参数顺序不同**）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来判断重载.     
>
> 重写：(Override)在子类中把父类本身有的方法重新写一遍。子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下， 对方法体进行修改或重写，这就是重写。但要注意子类函数的访问修饰权限不能少于父类的
>
> 区别：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，不能根据返回类型进行区分。

#### 谈谈你对this和super的认识

> this: 是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。
>
> super: 可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。
>
> ​	this的用法在java中大体可以分为3种：1.普通的直接引用，this相当于是指向当前对象本身。2.形参与成员名字重名，用this来区分;3.引用构造函数
>
> ​	super也有三种用法：1.普通的直接引用与this类似，super相当于是指向当前对象的父类，这样就可以用super.xxx来引用父类的成员。2.子类中的成员变量或方法与父类中的成员变量或方法同名.3.引用构造函数super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。

#### 接口和抽象类的区别

> 抽象类：抽象类往往用来表征对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。1、抽象类使用abstract修饰；2、抽象类不能实例化，即不能使用new关键字来实例化对象；3、含有抽象方法（使用abstract关键字修饰的方法）的类是抽象类，必须使用abstract关键字修饰；4、抽象类可以含有抽象方法，也可以不包含抽象方法，抽象类中可以有具体的方法；5、如果一个子类实现了父类（抽象类）的所有抽象方法，那么该子类可以不必是抽象类，否则就是抽象类；6、抽象类中的抽象方法只有方法体，没有具体实现；
>
> 接口：1、接口使用interface修饰；2、接口不能被实例化；3、一个类只能继承一个类，但是可以实现多个接口；4、接口中方法均为抽象方法；5、接口中不能包含实例域或静态方法（静态方法必须实现，接口中方法是抽象方法，不能实现）
>
> 抽象类要被子类继承，接口要被类实现。
>
> 接口只能做方法声明，抽象类中可以作方法声明，也可以做方法实现。
>
> 接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。
>
> 接口是设计的结果，抽象类是重构的结果。
>
> 抽象类主要用来抽象类别，接口主要用来抽象功能。
>
>  **interface的应用场合**
>
> 1. 类与类之前需要特定的接口进行协调，而不在乎其如何实现。
> 2. 作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。
> 3. 需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。
> 4. 需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。
>
> **abstract class的应用场合**
>
> 一句话，在既需要统一的接口，又需要实例变量或缺省的方法的情况下，就可以使用它。最常见的有：
>
> 1. 定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口。可以用abstract class定义一组方法体，甚至可以是空方法体，然后由子类选择自己所感兴趣的方法来覆盖。
> 2. 某些场合下，只靠纯粹的接口不能满足类与类之间的协调，还必需类中表示状态的变量来区别不同的关系。abstract的中介作用可以很好地满足这一点。
> 3. 规范了一组相互协调的方法，其中一些方法是共同的，与状态无关的，可以共享的，无需子类分别实现；而另一些方法却需要各个子类根据自己特定的状态来实现特定的功能

#### 静态属性和静态方法能被继承吗？静态方法又是否能被重写呢？

> 父类的静态属性和方法可以被子类继承
>
> 当父类的引用指向子类时，使用对象调用静态方法或者静态变量，是调用的父类中的方法或者变量。并没有被子类改写。 所以我认为不可以被子类重写。
>
> 静态方法不能被重写，不能实现多态。

#### 给我谈谈Java中的内部类

> 内部类：就是在一个类的内部定义另一个类。就像我们在类中声明成员变量一样，变量可以使用访问控制符，static，可以声明为成员变量或者函数内部的局部变量。内部类也可以有上述的用法，java中的内部类可以分为普通内部类（成员内部类），静态内部类，局部内部类和匿名内部类。
>
> 成员内部类——就是像普通的成员函数一样声明的内部类，InnerClass是OutClass的成员内部类，可以访问OutClass的成员变量。
>
> （1）可以使用public，private，protected或者默认的访问权限控制符声明，表示该内部类的访问权限；（2）可以访问外部类的成员变量和方法<内部类持有外部类的引用,java在编译内部类时会在其构造函数中默认添加外部类引用的参数，从而持有外部类的引用。>；（3）成员内部类**不能声明静态成员**；原因为==成员内部类就相当于外部类的一个普通的成员变量，当jvm加载外部类的时候并不会加载非静态变量，因此也就不会加载内部类。如果内部类可以声明静态变量，那么就会出现类还没有加载却要初始化静态变量的现象，因此java不会允许这种情况通过编译。
>
> 静态内部类——就是有static修饰的内部类，类似静态变量或者静态函数。相比于成员内部类对外部类的依赖，静态内部类基本不依赖外部类。通过其官方名称"**static nested classes**"(静态嵌套类)，更能说明其与外部类没有关系，只是自己的类声明嵌套在外部类的java文件中。静态内部类只能访问外部类的静态成员和方法，这点非常好理解，因为静态内部类和外部类没关系。静态内部类和静态变量或方法一样可以使用public，private，protected或者默认的访问权限控制符声明，这点也很好理解。
>
> <内部类的声明不再依赖外部类，可以完全独立声明对象，其实静态内部类不再持有外部类的引用>
>
> 局部内部类——就是声明在一个函数或者某个作用域中的内部类。可以看出局部内部类只作用于其所声明的函数或者局部作用域中，因此在局部内部类中不能使用public，private和protected。
>
> 匿名内部类——Runable是一个接口，我们通过new来实现了一个匿名内部类，这个类没有类名(其实真实编译后会以"外部类$数字"的形式作为类名)。匿名内部类，它可能引用三种外部变量：外部类的成员变量，外部方法或作用域内的局部变量，外部方法的参数。第一种变量是不需要声明为final的，但后两种是需要声明为final的。
>
> 使用内部类的作用：1）使用成员内部类可以使得内部类访问外部类的成员变量；
> （2）使用匿名内部类使得我们代码变得更简洁，不需要定义一些只是用一次的类；

#### static关键字的作用？

> 1.修饰变量：类变量，可以通过类名.变量名来访问
> 2.修饰方法：类方法
> 3.静态内部类
> 4.静态代码块
> 5.静态导包
>
> **一、特点：**
>
> 　　1、static是一个修饰符，用于修饰成员。（成员变量，成员函数）static修饰的成员变量	称之为静态变量或类变量。
>
> 　　2、static修饰的成员被所有的对象共享。
>
> 　　3、static优先于对象存在，因为static的成员随着类的加载就已经存在。
>
> 　　4、static修饰的成员多了一种调用方式，可以直接被类名所调用，（类名.静态成员）。
>
> 　　5、static修饰的数据是共享数据，对象中的存储的是特有的数据。
>
> **二、成员变量和静态变量的区别：**
>
> 　　1、生命周期的不同：
>
> 　　　　成员变量随着对象的创建而存在随着对象的回收而释放。
>
> 　　　　静态变量随着类的加载而存在随着类的消失而消失。
>
> 　　2、调用方式不同：
>
> 　　　　成员变量只能被对象调用。
>
> 　　　　静态变量可以被对象调用，也可以用类名调用。（推荐用类名调用）
>
> 　　3、别名不同：
>
> 　　　　成员变量也称为实例变量。
>
> 　　　　静态变量称为类变量。
>
> 　　4、数据存储位置不同：
>
> ​			成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据。
>
> 　　　　静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。
>
> **三、静态使用时需要注意的事项：**
>
> 　　1、静态方法只能访问静态成员。（非静态既可以访问静态，又可以访问非静态）
>
> 　　2、静态方法中不可以使用this或者super关键字。
>
> ​    	3、主函数是静态的
>
> **四、什么时候使用static来修饰**
>
> ​        1、静态变量：
>
> ​                （1）当分析对象中所具备的成员变量的值都是相同的。这时这个成员就可以被静态修饰。
>
> ​                （2）只要是数据在对象中都是不同的，就是对象的特有数据，必须存储在对象中，是非静态的。
>
> ​                （3）如果是相同的数据，对象不需要做修改，只需要使用即可，不需要存储在对象中，是静态的。
>
> ​	   2、静态函数。
>
> ​                （1）函数是否用静态修饰，就参考一点，就是该函数功能是否有访问到对象中特有的数据。
>
> ​                （2）简单来说，从源代码看，该功能是否需要访问非静态的成员变量，如果需要，该功能就是非静态的。如果不需要，就可以将该功能定义成静态的。当然，也可以定义成非静态，但是非静态需要被对象调用，而仅创建对象是没有意义的。
>
> ​        3、静态代码块：
>
> ​                （1）随着类的调用或创建实例而执行，而且只执行一次。
>
> ​                  作用：用于给类进行初始化。

#### final关键字的作用。

> final关键字可以用来修饰引用、方法和类。
>
> 用来修饰一个引用——1、 如果引用为基本数据类型，则该引用为常量，该值无法修改；2、 如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。3、如果引用时类的成员变量，则必须当场赋值，否则编译会报错。
>
> 用来修饰一个方法——当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。
>
> 用来修饰类——当用final修改类时，该类成为最终类，无法被继承。简称为“断子绝孙类”。比如常用的String类就是最终类。

#### Java Object类方法

> Object类是一个特殊的类，是所有类的父类，如果一个类没有用extends明确指出继承于某个类，那么它默认继承Object类。Object类有12个成员方法，按照用途可以分为以下几种
>
> 1，构造函数
> 2，hashCode和equale函数用来判断对象是否相同,
> 3，wait(),wait(long),wait(long,int),notify(),notifyAll()
> 4，toString()和getClass,
> 5，clone()
> 6，finalize()用于在垃圾回收
>
> **1.clone()**
>
> clone()函数的用途是用来另存一个当前存在的对象。
>
> **1.取得对象信息的方法：toString()**
>
> 该方法在打印对象时被调用，将对象信息变为字符串返回，默认输出对象地址。
>
> **2.对象相等判断方法：equals()**
>
> 该方法用于比较对象是否相等，而且此方法必须被重写。
>
> **3.对象签名:hashCode()**
>
> 该方法用来返回其所在对象的物理地址（哈希码值），常会和equals方法同时重写，确保相等的两个对象拥有相等的.hashCode。
>
> ①两个obj，如果equals()相等，hashCode()一定相等
>
> ②两个obj，如果hashCode()相等，equals()不一定相等

#### Synchronized原理

> synchronized关键字可以用在两处：
>
> 1.同步代码块，锁住的是任意的object，也可以是类；
>
> 2.同步方法,其中普通同步方法锁住的是类的实例对象，静态同步方法锁住的是这个类。在Android中，它们的实现原理都是通过monitor实现的。
>
> 大致过程是：monitor-enter（加锁）–>执行同步代码块或同步方法–>monitor-exit（释放锁）。
>
> https://hadyang.github.io/interview/docs/java/concurrent/synchronized/

#### Java 中深拷贝与浅拷贝的区别

> 浅拷贝---能复制变量，如果对象内还有对象，则只能复制对象的地址
>
> 深拷贝---能复制变量，也能复制当前对象的 内部对象
>
> 浅拷贝与深拷贝，一字之差，主要表明了拷贝的层次差别。
>
> Object的clone方法，必须要实现Cloneable。
>
> 表明了，clone方法的实现要程序员自己来。。。
>
> 而深浅拷贝只是术语的区别。。。你怎么实现的就是怎么个定义。
>
> 1. 必须实现Cloneable
>
>
> 1. 要深拷贝，得注意对象的内部对象，也需要clone



#### Java对象的完整生命周期

> 1).创建阶段(Created)
>
> 2).应用阶段(In Use)
>
> 3).不可见阶段(Invisible)
>
> 4).不可达阶段(Unreachable)
>
> 5).收集阶段(Collected)
>
> 6).终结阶段(Finalized)
>
> 7).对象空间重分配阶段(De-allocated)
>
> <https://blog.csdn.net/XiaoArea/article/details/87873727>

#### 进程间通信

> 进程间通信：
>
> **1. 管道(PIPE)**
>
> 管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
>
> **2. 命名管道(FIFO)**
>
> 名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
>
> **3. 信号(Signal)**
>
> 用于通知接收进程某个事件已经发生，主要作为进程间以及同一进程不同线程之间的同步手段。
>
> **4. 信号量(Semaphore)**
>
> 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。
>
> **5. 消息队列(MessageQueue)**
>
> 消息队列是消息的链表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
>
> **6. 共享内存(Shared Memory)**
>
> 共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。
>
> 特点：
>
> 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。
>
> 因为多个进程可以同时操作，所以需要进行同步。
>
> 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。
>
> **7. 套接字(Socket)**
>
> 套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。



#### Java引用类型

> 强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4 种，这 4 种引用的强度依次减弱。

#### 序列化和反序列化

> java序列化是指把java对象转换为字节序列的过程，而java反序列化是指把字节序列恢复为java对象的过程
>
> 序列化：对象序列化的最主要的用处就是在传递和保存对象的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。序列化后的字节流保存的java对象的状态以及相关的描述信息。序列化机制的核心作用就是对象状态的保存与重建。
>
> 反序列化：客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。
>
> 序列化就是把实体对象状态按照一定的格式写入到有序字节流，反序列化就是从有序字节流重建对象，恢复对象状态
>
> <https://www.cnblogs.com/baxianhua/p/10271830.html>

#### 重写equals方法的要求

1、自反性：对于任何非空引用x，x.equals(x)应该返回true。2、对称性：对于任何引用x和y，如果x.equals(y)返回true，那么y.equals(x)也应该返回true。3、传递性：对于任何引用x、y和z，如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也应该返回true。4、一致性：如果x和y引用的对象没有发生变化，那么反复调用x.equals(y)应该返回同样的结果。5、非空性：对于任意非空引用x，x.equals(null)应该返回false。

#### sleep和wait的区别

1. 这两个方法来自不同的类分别是Thread和Object  

2.  sleep()不释放同步锁,wait()释放同步锁.   sleep(milliseconds)可以用时间指定来使他自动醒过来,如果时间不到你只能调用interreput()来强行打断;       wait()可以用notify()直接唤起

3. wait,notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用   synchronized(x){    x.notify()    //或者wait()   }  4.sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常

  wait 为什么要用在同步块中?为了避免出现lost wake up问题

> **lost wake up:**
>
> 假如有两个线程，一个消费者线程，一个生产者线程。生产者线程的任务可以简化成将count加一，而后唤醒消费者；消费者则是将count减一，而后在减到0的时候陷入睡眠：
>
> 万一这些步骤混杂在一起呢？比如说，初始的时候count等于0，这个时候消费者检查count的值，发现count小于等于0的条件成立；就在这个时候，发生了上下文切换，生产者进来了，噼噼啪啪一顿操作，把两个步骤都执行完了，也就是发出了通知，准备唤醒一个线程。这个时候消费者刚决定睡觉，还没睡呢，所以这个通知就会被丢掉。紧接着，消费者就睡过去了…
>
> **问题的根源：消费者线程检查count到调用wait之间，count有可能被改掉了。（竞态条件）**

#### 动态库和静态库的区别

一，静态库的使用需要：
1 包含一个对应的头文件告知编译器lib文件里面的具体内容
2 设置lib文件允许编译器去查找已经编译好的二进制代码
二，动态库的使用：
  程序运行时需要加载动态库，对动态库有依赖性，需要手动加入动态库
三，依赖性：
     静态链接表示静态性，在编译链接之后， lib库中需要的资源已经在可执行程序中了， 也就是静态存在，没有依赖性了;  动态，就是实时性，在运行的时候载入需要的资源，那么必须在运行的时候提供 需要的 动态库，有依赖性， 运行时候没有找到库就不能运行了
四，区别：简单讲，静态库就是直接将需要的代码连接进可执行程序；动态库就是在需要调用其中的函数时，根据  函数映射表找到该函数然后调入堆栈执行。
   做成静态库可执行文件本身比较大，但不必附带动态库
   做成动态库可执行文件本身比较小，但需要附带动态库
五，首先纠正所谓“静态连接就是把需要的库函数放进你的exe之中”的说法。在真实世界中，有三个概念：Use static libary, static linked DLL, dynamic linked DLL.
多数人混淆了static libary 和 static linked DLL的概念，当然他们有似是而非的“相似之处”，比如都用到.lib，下面具体说明。
使用静态库(Use static libary)是把.lib和其他.obj一起build在目标文件中，目标文件可以是.exe,也可以是.dll或.oxc等。一般情况下，可以根本就没有“对应的”.dll 文件，如C Run Time(CRT)库。一个例子就是，写一个main(){}，build出来并不是只有几个字节，当然有人会说那还有exe文件头呢？是，即使加上文件头的尺寸，build出的执行文件仍然“莫名的大”。实际上那多出来的部分就是CRT静态库。姑且可以把静态库.lib理解成外部程序的obj文件比较合理，它包含了函数的实现。

#### 强引用、弱引用与软引用，虚引用区别

强引用：对象具有强引用时垃圾回收器不会回收，jvm宁愿抛出oom也不回收。

软引用（softReference）：1.没有任何强引用指向软引用指向的对象时。2.JVM内存不足时，ooM之前才会回收。 

弱引用（weakReference）：1.没有任何强引用指向弱引用所指向的对象。2.不改变原有的强引用的垃圾回收机制，一旦指示对象没有任何强引用时，此对象进入正常的垃圾回收流程。（handler中使用防止内存泄漏） 

软引用和弱引用可以跟ReferenceQueue联合使用，其指示的对象已经被回收，jvm将软引用或弱引用加入到与之关联的引用队列中。利用ReferenceQueue.poll 检测软（弱）引用指向的对象是否已被回收，清除这些softReference或weakReference对象。 

虚引用不能保证其保存对象生命周期，其保存对象若只有虚引用，则其有效期完全随机于GC的回收，在任何一个不确定的时间内，都可能会被回收；而虚引用与其他几者的引用不同在于，在使用PhantomReference，必须要和ReferenceQueue联合使用。

 软引用和弱引用的选择？

1.如果只是避免oom，使用softReference（软引用）

2.如果是想尽快回收对象使用weakReference（弱引用）

3.如果对象经常使用尽力使用软引用；如果对象被使用的几率不大使用弱引用。

#### 重载和多态的区别

多态是建立在重写的基础之上的，是类与类之间的关系，是发生在不同的类之间的，子类重写父类的方法。实现不同的子类，不同的实现形态。
多态有3个条件
1:继承
2:重写(重写父类继承的方法)
3:父类引用指向子类对象

而重载是类的内部的方法构型上的不同，是发生在同一个类里面的。同一个函数名称，参数不同的多个方法，实现同一类型的功能。

#### 什么是泛型？能解决什么问题？

- 泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。

  泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。

#### 在泛型中extends和super关键字的区别是什么？

- <? extends T> 表示类型的上界，表示参数化类型的可能是T 或是 T的子类

  <? super T> 表示类型下界（Java Core中叫超类型限定），表示参数化类型是此类型的超类型


- 在Java中List< A >和List< B >是一样的类型还是不一样的类型？为什么？
  - 如在代码中定义的List<object>和List<String>等类型，在编译后都会编程List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况

#### 说说Java中泛型的工作机制？

- Java的泛型是伪泛型。在编译期间，所有的泛型信息都会被擦除掉。正确理解泛型概念的首要前提是理解类型擦出（type erasure）。

  Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会在编译器在编译的时候去掉。这个过程就称为类型擦除。

  举例：如在代码中定义的List<object>和List<String>等类型，在编译后都会编程List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。类型擦除也是Java的泛型实现方法与C++模版机制实现方式（后面介绍）之间的重要区别

#### 泛型的优点

1、性能

对值类型使用非泛型集合类，在把值类型转换为引用类型，和把引用类型转换为值类型时，需要进行装箱和拆箱操作。装箱和拆箱的操作很容易实现，但是性能损失较大。假如使用泛型，就可以避免装箱和拆箱操作。

2、类型安全

　与ArrayList类一样，如果使用对象，可以在这个集合中添加任意类型。

​    如果该用泛型编程，则可以避免这种异常，让编译器检查出错误。