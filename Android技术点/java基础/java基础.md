# Java基础

[Toc]

#### 什么是重载 & 什么是重写 & 区别

> 重载：(Overload)在同一个类中，同名的方法如果有不同的参数列表（**参数类型不同、参数个数不同甚至是参数顺序不同**）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来判断重载.     
>
> 重写：(Override)在子类中把父类本身有的方法重新写一遍。子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下， 对方法体进行修改或重写，这就是重写。但要注意子类函数的访问修饰权限不能少于父类的
>
> 区别：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，不能根据返回类型进行区分。

#### 谈谈你对this和super的认识

> this: 是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。
>
> super: 可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。
>
> ​	this的用法在java中大体可以分为3种：1.普通的直接引用，this相当于是指向当前对象本身。2.形参与成员名字重名，用this来区分;3.引用构造函数
>
> ​	super也有三种用法：1.普通的直接引用与this类似，super相当于是指向当前对象的父类，这样就可以用super.xxx来引用父类的成员。2.子类中的成员变量或方法与父类中的成员变量或方法同名.3.引用构造函数super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。

#### 接口和抽象类的区别

> 抽象类：1、抽象类使用abstract修饰；2、抽象类不能实例化，即不能使用new关键字来实例化对象；3、含有抽象方法（使用abstract关键字修饰的方法）的类是抽象类，必须使用abstract关键字修饰；4、抽象类可以含有抽象方法，也可以不包含抽象方法，抽象类中可以有具体的方法；5、如果一个子类实现了父类（抽象类）的所有抽象方法，那么该子类可以不必是抽象类，否则就是抽象类；6、抽象类中的抽象方法只有方法体，没有具体实现；
>
> 接口：1、接口使用interface修饰；2、接口不能被实例化；3、一个类只能继承一个类，但是可以实现多个接口；4、接口中方法均为抽象方法；5、接口中不能包含实例域或静态方法（静态方法必须实现，接口中方法是抽象方法，不能实现）

#### 静态属性和静态方法能被继承吗？静态方法又是否能被重写呢？

> 父类的静态属性和方法可以被子类继承
>
> 当父类的引用指向子类时，使用对象调用静态方法或者静态变量，是调用的父类中的方法或者变量。并没有被子类改写。 所以我认为不可以被子类重写。
>
> 静态方法不能被重写，不能实现多态。

#### 给我谈谈Java中的内部类

> 内部类：就是在一个类的内部定义另一个类。就像我们在类中声明成员变量一样，变量可以使用访问控制符，static，可以声明为成员变量或者函数内部的局部变量。内部类也可以有上述的用法，java中的内部类可以分为普通内部类（成员内部类），静态内部类，局部内部类和匿名内部类。
>
> 成员内部类——就是像普通的成员函数一样声明的内部类，InnerClass是OutClass的成员内部类，可以访问OutClass的成员变量。
>
> （1）可以使用public，private，protected或者默认的访问权限控制符声明，表示该内部类的访问权限；（2）可以访问外部类的成员变量和方法<内部类持有外部类的引用,java在编译内部类时会在其构造函数中默认添加外部类引用的参数，从而持有外部类的引用。>；（3）成员内部类不能声明静态成员；原因为==成员内部类就相当于外部类的一个普通的成员变量，当jvm加载外部类的时候并不会加载非静态变量，因此也就不会加载内部类。如果内部类可以声明静态变量，那么就会出现类还没有加载却要初始化静态变量的现象，因此java不会允许这种情况通过编译。
>
> 静态内部类——就是有static修饰的内部类，类似静态变量或者静态函数。相比于成员内部类对外部类的依赖，静态内部类基本不依赖外部类。通过其官方名称"**static nested classes**"(静态嵌套类)，更能说明其与外部类没有关系，只是自己的类声明嵌套在外部类的java文件中。静态内部类只能访问外部类的静态成员和方法，这点非常好理解，因为静态内部类和外部类没关系。静态内部类和静态变量或方法一样可以使用public，private，protected或者默认的访问权限控制符声明，这点也很好理解。
>
> <内部类的声明不再依赖外部类，可以完全独立声明对象，其实静态内部类不再持有外部类的引用>
>
> 局部内部类——就是声明在一个函数或者某个作用域中的内部类。可以看出局部内部类只作用于其所声明的函数或者局部作用域中，因此在局部内部类中不能使用public，private和protected。
>
> 匿名内部类——Runable是一个接口，我们通过new来实现了一个匿名内部类，这个类没有类名(其实真实编译后会以"外部类$数字"的形式作为类名)。匿名内部类，它可能引用三种外部变量：外部类的成员变量，外部方法或作用域内的局部变量，外部方法的参数。第一种变量是不需要声明为final的，但后两种是需要声明为final的。
>
> 使用内部类的作用：1）使用成员内部类可以使得内部类访问外部类的成员变量；
> （2）使用匿名内部类使得我们代码变得更简洁，不需要定义一些只是用一次的类；

#### static关键字的作用？

> 1.修饰变量：类变量，可以通过类名.变量名来访问
> 2.修饰方法：类方法
> 3.静态内部类
> 4.静态代码块
> 5.静态导包
>
> **一、特点：**
>
> 　　1、static是一个修饰符，用于修饰成员。（成员变量，成员函数）static修饰的成员变量	称之为静态变量或类变量。
>
> 　　2、static修饰的成员被所有的对象共享。
>
> 　　3、static优先于对象存在，因为static的成员随着类的加载就已经存在。
>
> 　　4、static修饰的成员多了一种调用方式，可以直接被类名所调用，（类名.静态成员）。
>
> 　　5、static修饰的数据是共享数据，对象中的存储的是特有的数据。
>
> **二、成员变量和静态变量的区别：**
>
> 　　1、生命周期的不同：
>
> 　　　　成员变量随着对象的创建而存在随着对象的回收而释放。
>
> 　　　　静态变量随着类的加载而存在随着类的消失而消失。
>
> 　　2、调用方式不同：
>
> 　　　　成员变量只能被对象调用。
>
> 　　　　静态变量可以被对象调用，也可以用类名调用。（推荐用类名调用）
>
> 　　3、别名不同：
>
> 　　　　成员变量也称为实例变量。
>
> 　　　　静态变量称为类变量。
>
> 　　4、数据存储位置不同：
>
> ​		成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据。
>
> 　　　　静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。
>
> **三、静态使用时需要注意的事项：**
>
> 　　1、静态方法只能访问静态成员。（非静态既可以访问静态，又可以访问非静态）
>
> 　　2、静态方法中不可以使用this或者super关键字。
>
> ​	3、主函数是静态的
>
> **四、什么时候使用static来修饰**
>
> ​        1、静态变量：
>
> ​                （1）当分析对象中所具备的成员变量的值都是相同的。这时这个成员就可以被静态修饰。
>
> ​                （2）只要是数据在对象中都是不同的，就是对象的特有数据，必须存储在对象中，是非静态的。
>
> ​                （3）如果是相同的数据，对象不需要做修改，只需要使用即可，不需要存储在对象中，是静态的。
>
> ​	2、静态函数。
>
> ​                （1）函数是否用静态修饰，就参考一点，就是该函数功能是否有访问到对象中特有的数据。
>
> ​                （2）简单来说，从源代码看，该功能是否需要访问非静态的成员变量，如果需要，该功能就是非静态的。如果不需要，就可以将该功能定义成静态的。当然，也可以定义成非静态，但是非静态需要被对象调用，而仅创建对象是没有意义的。
>
> ​        3、静态代码块：
>
> ​                （1）随着类的调用或创建实例而执行，而且只执行一次。
>
> ​                作用：用于给类进行初始化。

#### final关键字的作用。

> final关键字可以用来修饰引用、方法和类。
>
> 用来修饰一个引用——1、 如果引用为基本数据类型，则该引用为常量，该值无法修改；2、 如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。3、如果引用时类的成员变量，则必须当场赋值，否则编译会报错。
>
> 用来修饰一个方法——当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。
>
> 用来修饰类——当用final修改类时，该类成为最终类，无法被继承。简称为“断子绝孙类”。比如常用的String类就是最终类。

#### Java Object类方法

> Object类是一个特殊的类，是所有类的父类，如果一个类没有用extends明确指出继承于某个类，那么它默认继承Object类。Object类有12个成员方法，按照用途可以分为以下几种
>
> 1，构造函数
> 2，hashCode和equale函数用来判断对象是否相同,
> 3，wait(),wait(long),wait(long,int),notify(),notifyAll()
> 4，toString()和getClass,
> 5，clone()
> 6，finalize()用于在垃圾回收
>
> **1.clone()**
>
> clone()函数的用途是用来另存一个当前存在的对象。
>
> **1.取得对象信息的方法：toString()**
>
> 该方法在打印对象时被调用，将对象信息变为字符串返回，默认输出对象地址。
>
> **2.对象相等判断方法：equals()**
>
> 该方法用于比较对象是否相等，而且此方法必须被重写。
>
> **3.对象签名:hashCode()**
>
> 该方法用来返回其所在对象的物理地址（哈希码值），常会和equals方法同时重写，确保相等的两个对象拥有相等的.hashCode。
>
> ①两个obj，如果equals()相等，hashCode()一定相等
>
> ②两个obj，如果hashCode()相等，equals()不一定相等

#### Synchronized原理

> synchronized关键字可以用在两处：
>
> 1.同步代码块，锁住的是任意的object，也可以是类；
>
> 2.同步方法,其中普通同步方法锁住的是类的实例对象，静态同步方法锁住的是这个类。在Android中，它们的实现原理都是通过monitor实现的。
>
> 大致过程是：monitor-enter（加锁）–>执行同步代码块或同步方法–>monitor-exit（释放锁）。
>
> https://hadyang.github.io/interview/docs/java/concurrent/synchronized/

#### Java 中深拷贝与浅拷贝的区别

> 浅拷贝---能复制变量，如果对象内还有对象，则只能复制对象的地址
>
> 深拷贝---能复制变量，也能复制当前对象的 内部对象
>
> 浅拷贝与深拷贝，一字之差，主要表明了拷贝的层次差别。
>
> Object的clone方法，必须要实现Cloneable。
>
> 表明了，clone方法的实现要程序员自己来。。。
>
> 而深浅拷贝只是术语的区别。。。你怎么实现的就是怎么个定义。
>
> 1. 必须实现Cloneable
>
>
> 1. 要深拷贝，得注意对象的内部对象，也需要clone

#### Java GC机制（可达性分析法，引用计数法）

> 1. 引用计数法：
>
> 是垃圾收集的早期策略，在这个方法中，堆中每个对象都有一个引用计数，每当有一个地方引用他时，引用计数值就+1,当引用失效时，引用计数值就-1，任何时刻引用计数值为0的对象就是可以被回收，当一个对象被垃圾收集时，被它引用 的对象引用计数值就-1，所以在这种方法中一个对象被垃圾收集会导致后续其他对象的垃圾收集行动。
>
> 优点：判定效率高；
>
> 缺点：不完全准确，当两个对象相互引用的时候就无法回收，导致内存泄漏。
>
> 1. 可达性分析：
>
>  这个算法的基本思路就是通过一系列名为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，比如对象object1, object2, object3是相互引用，但它们到GC Roots是不可达的，所以它们将会判定为是可回收对象。
>
> 1. 在Java语言里，可作为GC Roots对象的包括如下几种：
>
> a,虚拟机栈(栈桢中的本地变量表)中的引用的对象
>
> b,方法区中的类静态属性引用的对象
>
> c,方法区中的常量引用的对象
>
> d,本地方法栈中JNI的引用的对象 
>
> <https://blog.csdn.net/qq_34996727/article/details/80672853>

#### Java对象的完整生命周期

> 1).创建阶段(Created)
>
> 2).应用阶段(In Use)
>
> 3).不可见阶段(Invisible)
>
> 4).不可达阶段(Unreachable)
>
> 5).收集阶段(Collected)
>
> 6).终结阶段(Finalized)
>
> 7).对象空间重分配阶段(De-allocated)
>
> <https://blog.csdn.net/XiaoArea/article/details/87873727>

#### JVM内存模型

![img](https://upload-images.jianshu.io/upload_images/1592745-3f82fafa66408ed9.png?imageMogr2/auto-orient/strip|imageView2/2/w/727/format/webp)

> <https://www.jianshu.com/p/0ecf020614cb>

#### 进程间通信

> 进程间通信：
>
> **1. 管道(PIPE)**
>
> 管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
>
> **2. 命名管道(FIFO)**
>
> 名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
>
> **3. 信号(Signal)**
>
> 用于通知接收进程某个事件已经发生，主要作为进程间以及同一进程不同线程之间的同步手段。
>
> **4. 信号量(Semaphore)**
>
> 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。
>
> **5. 消息队列(MessageQueue)**
>
> 消息队列是消息的链表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
>
> **6. 共享内存(Shared Memory)**
>
> 共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。
>
> 特点：
>
> 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。
>
> 因为多个进程可以同时操作，所以需要进行同步。
>
> 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。
>
> **7. 套接字(Socket)**
>
> 套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。

#### JVM类加载机制

> 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking），这7个阶段的发生顺序如图：
>
> ![这里写图片描述](https://img-blog.csdn.net/20170907001317206?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2lsZW5jZU9P/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
>
> <https://blog.csdn.net/SilenceOO/article/details/77876123>

#### Java引用类型

> 强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4 种，这 4 种引用的强度依次减弱。

#### 序列化和反序列化

> java序列化是指把java对象转换为字节序列的过程，而java反序列化是指把字节序列恢复为java对象的过程
>
> 序列化：对象序列化的最主要的用处就是在传递和保存对象的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。序列化后的字节流保存的java对象的状态以及相关的描述信息。序列化机制的核心作用就是对象状态的保存与重建。
>
> 反序列化：客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。
>
> 序列化就是把实体对象状态按照一定的格式写入到有序字节流，反序列化就是从有序字节流重建对象，恢复对象状态
>
> <https://www.cnblogs.com/baxianhua/p/10271830.html>

**重写equals方法的要求：**1、自反性：对于任何非空引用x，x.equals(x)应该返回true。2、对称性：对于任何引用x和y，如果x.equals(y)返回true，那么y.equals(x)也应该返回true。3、传递性：对于任何引用x、y和z，如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也应该返回true。4、一致性：如果x和y引用的对象没有发生变化，那么反复调用x.equals(y)应该返回同样的结果。5、非空性：对于任意非空引用x，x.equals(null)应该返回false。

**类的双亲委托机制**：当某个特定的类加载器在接收到加载类的请求时，首先将该加载任务发送给父类加载器，若父类加载器仍有父类，则继续向上追溯，直到最高级。如果最高级父类能够加载到该类，则成功返回，否则由其子类进行加载。以此类推，如果到最后一个子类还不能成功加载，则抛出一个异常。作用：可以保证java核心库或第三方库的安全（防止低一级加载器加载的类覆盖高级加载器加载的类）

#### 动态库和静态库的区别

一，静态库的使用需要：
1 包含一个对应的头文件告知编译器lib文件里面的具体内容
2 设置lib文件允许编译器去查找已经编译好的二进制代码
二，动态库的使用：
  程序运行时需要加载动态库，对动态库有依赖性，需要手动加入动态库
三，依赖性：
     静态链接表示静态性，在编译链接之后， lib库中需要的资源已经在可执行程序中了， 也就是静态存在，没有依赖性了;  动态，就是实时性，在运行的时候载入需要的资源，那么必须在运行的时候提供 需要的 动态库，有依赖性， 运行时候没有找到库就不能运行了
四，区别：简单讲，静态库就是直接将需要的代码连接进可执行程序；动态库就是在需要调用其中的函数时，根据  函数映射表找到该函数然后调入堆栈执行。
   做成静态库可执行文件本身比较大，但不必附带动态库
   做成动态库可执行文件本身比较小，但需要附带动态库
五，首先纠正所谓“静态连接就是把需要的库函数放进你的exe之中”的说法。在真实世界中，有三个概念：Use static libary, static linked DLL, dynamic linked DLL.
多数人混淆了static libary 和 static linked DLL的概念，当然他们有似是而非的“相似之处”，比如都用到.lib，下面具体说明。
使用静态库(Use static libary)是把.lib和其他.obj一起build在目标文件中，目标文件可以是.exe,也可以是.dll或.oxc等。一般情况下，可以根本就没有“对应的”.dll 文件，如C Run Time(CRT)库。一个例子就是，写一个main(){}，build出来并不是只有几个字节，当然有人会说那还有exe文件头呢？是，即使加上文件头的尺寸，build出的执行文件仍然“莫名的大”。实际上那多出来的部分就是CRT静态库。姑且可以把静态库.lib理解成外部程序的obj文件比较合理，它包含了函数的实现。