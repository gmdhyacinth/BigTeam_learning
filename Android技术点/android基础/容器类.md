## 容器类



### 扩容：

HashTable在不指定容量的情况下的默认容量为11,而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。

Hashtable扩容因子是0.75,扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。

Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。

ArrayList：ArrayList就是Object数组：初始化的时候会创建一个初始化长度为10的数组，而后的数组扩容才是按照当前容量的1.5倍进行扩容；

在扩容机制上，当Vector的元素数量超过它的初始化大小的时候会将容量翻倍，而ArrayList只会增长50%。



### 线程安全：

hashMap非线程安全

ConcurrentHashMap使用的分段锁技术，线程安全

Vector：就比ArrayList多了一个同步化机制，线程安全

LinkedList因为成员方法大多是synchronized的，线程安全

HashTable：比hashMap多了一个线程安全。hashTable的方法都提供了同步机制。

ConcurrentHashMap：是一种高效但是也线程安全的集合

StringBuffer是线程安全的，而StringBuilder是线程不安全的，默认长度均为 16，尝试将新容量扩为 大小：变成2倍+2，容量如果还不够，直接扩充到需要的容量大小；



**BlockingQueue**

ArrayBlockingQueue：
FIFO、数组实现,有界阻塞队列，一旦指定了队列的长度，则队列的大小不能被改变，没有实现读写分离，也就是说，读和写是不能同时进行

DelayQueue:
有界阻塞延时队列，当队列里的元素延时期未到时，通过take方法不能获取，会被阻塞，直到有元素延时到期为止。 
首先定义数据元素，需要实现 Delayed 接口，实现 getDelay 方法用于计算剩余时间，和 CompareTo方法用于优先级排序。

LinkedBlockingQueue: 
FIFO、Node链表结构, 可以通过构造方法设置capacity来使得阻塞队列是有界的，也可以不设置，则为无界队列，有内存耗尽风险；实现了读写分离，可以实现数据的读和写互不影响

PriorityBlockingQueue：支持优先级排序的无界队列，相当于PriorityQueue + BlockingQueue 插入的对象必须是可比较的，或者通过构造方法实现插入对象的比较器Comparator<? super E> 
队列里的元素按Comparator<? super E> comparator比较结果排序
可以指定初始容量大小（注意初始容量并不代表最大容量），或者不指定，默认大小为 11。也可以传入一个比较器，把元素按一定的规则排序，不指定比较器的话，默认是自然顺序。
是基于二叉树最小堆实现的

SynchronousQueue ：
无内部容量的阻塞队列，put必须等待take，同样take必须等待put。比较适合两个线程间的数据传递。



### 其他：

[Hash碰撞](Hash碰撞问题.md)

