### Activity展示

结构：Window/Decorview/ViewRoot

![activity_ui层次](..\images\activity_ui层次.png)

**WMS作用**：分配surface，掌管surface显示顺序及位置尺寸等，控制窗口动画，输入时间分发

我们开始看Activity代码：

    setConentView方法：getWindow().setConentView()
    attach方法创建的window=new PhoneWindow
    
    我们看一下PhoneWindow的setConentView
    void setConentView(int layoutId){
       if(mContentParent == null){
          installDecor();// decorview = new Decorview; decorview.addView();
       }
       layoutInflate.inflate(layoutId, mContentParent);
    }
    void installDecor(){
      mDecor= new Decorview(getContext());
      View in = mLayoutInflater.inflate(layoutResourse, null);
      mDecor.adddView(in,...);
      mContentParent = findViewById(ID_ANDROID_CONTENT);
    }
    
    看一下ActivityThread的handleResumeActivity()
     View decor = r.window.getDecorView();
     ViewManager wm = a.getWindowManager();
     wm.addView(decor) 调用 mGlobal.addView();
    
    再看WindowManagerGlobal的addView
    void addView（View view,Layoutparas params,...）{
      ViewRootImpl root = new ViewRootImpl(view.getContext());
      root.setView(view, wParams,panelParentView );
    }
    
    ViewRootImpl的setView方法
    setView(View view,...){
      if(mView == null){//只能管理一个view
         mView = view;
    	 requestLayout();//触发绘制
    	 ...
    	 mWindowSession.addToDisplay(mWindow, ...);
    	 ...
      }  
    }
    先介绍requestLayout
    void requestLayout(){
      ...
      checkThread();//检查是否是同一线程
      scheduleTraversals();
    }
    
    void scheduleTraversals(){
       ...
       mChoreographer.postCallBack(.., mTraversalRunnable, null);
    }
    
    mTraversalRunnable:doTraversal()->performTraversal()
    
    performTraversal(){
      ...
      relayoutWindow(params, ...);//mwindowsSession.relayout(..., mSurface) 执行完这个方法，mSurface就能用了,surfaceFlinger 就可以渲染了
      ...
      performMeasure(childWidthMeasureSpec, ...);//执行view的messure()
      ...
      performLayout(lp, desiredWindowWidth);//执行view的layout()，requestLayout()
      。。。
      performDraw();//执行view的draw()
      。。。 
    }
    
    然后看 mWindowSession.addToDisplay(mWindow, ...)
    mWindowSession是windowsmanager创建的，在openSession()方法




### UI刷新

UI线程启动：
ui线程是刷新ui所在的线程，UI是单线程刷新的，否则需要上锁同步

    刷新方式：
    activity.runOnUiThread(Runnable action){
      if(当前线程 != mUiThread){
         mHandler.post(action)
      }else{
        action.run()
      }  
    }
    
    View.post(Runnable r) 
    
    handler.post(Runnable r）；
    
    AsyncTask
//activity创建的handler

```
finale Handler mHandler = new Handler();

final void attach(Context context, ...){
   mUIThread = 当前线程
}
```

对于activity来说，ui线程就是主线程

ViewRootImpl 在onresume之后才创建

ActivityThread.handleResumeActivity -> windowManagerImpl.addView -> windowManagerGlobal.addView -> ViewRootImpl创建
Activity的Decorview对应的ViewRootImpl是在主线程创建的

能不能刷新ui主要取决于ViewRootImpl创建所在线程



小测验：
new Thread(){
  Looper.prepare();
  getWindowManager().addView(view， params);
  //可以修改ui，可以添加点击，但是必须在线程里处理，原因是什么呢？

  Looper.loop(); 
}



#### View的渲染流程

![view_root_tree](..\images\view_root_tree.png)

整个 View 树的绘图流程在ViewRoot.java类的performTraversals()函数展开，其绘制流程如下：(图用的别人的，见文后链接)

![view_display](..\images\view_display.png)

UI绘制机制是入口在哪里呢？就是ViewRootImpl类的performTraversals()方法。在这个方法内部，分别调用measure、layout、draw方法来进行View的三大工作流程。(见上文分析)

然后看viewgroup和view中的几个关键方法：

测量方法执行流程：

measure()->onMeasure()

view排布：

layout()->onLayout()

刷新方法执行流程：

draw()->drawBackground->onDraw() 绘制内容->dispatchDraw( ) viewgroup绘制子view->  onDrawForeground

ViewGroup中dispatchDraw()->drawChild(canvas,child, drawingTime(动画时间))



然后我们看addView和removeView时候view的刷新情况

```
public void addView(View child, int index, LayoutParams params) {
    requestLayout();
    invalidate(true);
    addViewInner(child, index, params, false);
}


public void removeView(View view) {
     if (removeViewInternal(view)) {
            requestLayout();
            invalidate(true);
     }
}
```

这两个方法，都有requestLayout，我们看看requestLayout究竟做了什么事

```
public void requestLayout() {
    if (mAttachInfo != null && mAttachInfo.mViewRequestingLayout == null) {
         ...
         //记录发起requestlayout的view
        mAttachInfo.mViewRequestingLayout = this;
    }
    //做标记
    mPrivateFlags |= PFLAG_FORCE_LAYOUT;
    mPrivateFlags |= PFLAG_INVALIDATED;
    //通知父view
    if (mParent != null && !mParent.isLayoutRequested()) {
        mParent.requestLayout();
    }
    if (mAttachInfo != null && mAttachInfo.mViewRequestingLayout == this) {
         //清除发起requestlayout的view记录
        mAttachInfo.mViewRequestingLayout = null;
    }
}
```

在requestLayout方法中，首先先为当前View设置上PFLAG_FORCE_LAYOUT的标记位，表示当前的View需要重新绘制。接下来会判断当前View树是否正在布局流程，当父布局已经开始重新布局的时候，不会继续传递重新布局的请求，而是带着FORCE_LAYOUT的标记等待重新绘制的流程走到这里。当并没有已经在重新布局的时候，接着调用mParent.requestLayout方法，为父容器添加PFLAG_FORCE_LAYOUT标记位，而父容器又会调用它的父容器的requestLayout方法.
 requestLayout的事件会层层上传，直到DecorView，即根View，而根View又会传递给ViewRootImpl。
 即是说任何一个View的requestLayout事件，最终会被ViewRootImpl接收并得到处理。



参考文章：

1.https://blog.csdn.net/Rayht/article/details/80782697



