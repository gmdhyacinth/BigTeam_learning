## 设计模式的六大原则：

- Single Responsibility Principle：单一职责原则
- Open Closed Principle：开闭原则
- Liskov Substitution Principle：里氏替换原则
- Law of Demeter：迪米特法则
- Interface Segregation Principle：接口隔离原则
- Dependence Inversion Principle：依赖倒置原则

#### 1、单一职责原则（Single Responsibility Principle）

一个类应该只有一个发生变化的原因

> There should never be more than one reason for a class to change.

理解：不同的类具备不同的职责，各司其职。做系统设计是，如果发现有一个类拥有了两种职责，那么就要问一个问题：可以将这个类分成两个类吗？如果真的有必要，那就分开，千万不要让一个类干的事情太多。

总结：一个类只承担一个职责

[六大设计原则之单一职责原则（SRP）](https://www.jianshu.com/p/526a70f24ac5)

#### 2、开闭原则（Open Closed Principle）

一个软件实体，如类、模块和函数应该对扩展开放，对修改关闭

> Software entities like classes, modules and functions should be open for extension but closed for modification

理解：类、模块、函数，可以去扩展，但不要去修改。如果要修改代码，尽量用继承或组合的方式来扩展类的功能，而不是直接修改类的代码。当然，如果能保证对整个架构不会产生任何影响，那就没必要搞的那么复杂，直接改这个类吧。

总结：对软件实体的改动，最好用扩展而非修改的方式。

[六大设计原则之开闭原则（OCP）](https://www.jianshu.com/p/55c3482d6e00)

#### 3、里氏替换原则（Liskov Substitution Principle）

所有引用基类的地方必须能透明地使用其子类的对象

> Functions that use use pointers or references to base classes must be able to use objects of derived classes without knowing it.

[六大设计原则之里氏替换原则（LSP）](https://www.jianshu.com/p/dfcdcd5d9ece)

里氏替换原则对继承进行了规则上的约束，这种约束主要体现在四个方面：

- 子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法。
- 子类中可以增加自己特有的方法。
- 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比- 父类方法的输入参数更宽松。(即只能重载不能重写)
- 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格

#### 4、迪米特法则（Law of Demeter）

只与你的直接朋友交谈，不跟“陌生人”说话

> Talk only to your immediate friends and not to strangers

其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。

[六大设计原则之迪米特法则（LOD）](https://www.jianshu.com/p/98761ad06de6)

#### 5、接口隔离原则（Interface Segregation Principle）

1、客户端不应该依赖它不需要的接口。
2、类间的依赖关系应该建立在最小的接口上。

> Clients should not be forced to depend upon interfaces that they don`t use.
> The dependency of one class to another one should depend on the smallest possible.

注：该原则中的接口，是一个泛泛而言的接口，不仅仅指Java中的接口，还包括其中的抽象类。

[六大设计原则之接口隔离原则（ISP）](https://www.jianshu.com/p/3232c9891403)

#### 6、依赖倒置原则（Dependence Inversion Principle）

1、上层模块不应该依赖底层模块，它们都应该依赖于抽象。
2、抽象不应该依赖于细节，细节应该依赖于抽象。

> High level modules should not depend upon low level modules. Both should depend upon abstractions.
> Abstractions should not depend upon details. Details should depend upon abstractions.

[依赖倒置原则(DIP)](https://www.jianshu.com/p/c3ce6762257c)

参考：

- [设计模式六大原则——SOLID](https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Frocketeerli%2Farticle%2Fdetails%2F81585705)

- [六大设计原则之里氏替换原则（LSP）](https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fqq_34966814%2Farticle%2Fdetails%2F79475977)

  ​

## 设计模式

#### Builder模式：

##### 模式的定义

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

##### 模式的使用场景

1. 相同的方法，不同的执行顺序，产生不同的事件结果时；
2. 多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时；
3. 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适；

##### 角色介绍

- Product 产品类 : 产品的抽象类。
- Builder : 抽象类， 规范产品的组建，一般是由子类实现具体的组件过程。
- ConcreteBuilder : 具体的构建器.
- Director : 统一组装过程(可省略)。

### 单例模式：

##### 模式的定义

确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

##### 模式的使用场景

确保某个类有且只有一个对象的场景，例如创建一个对象需要消耗的资源过多，如要访问 IO 和数据库等资源。

实现：

```
/**
	 * 方式2、double-check， 避免并发时创建了多个实例, 该方式不能完全避免并发带来的破坏.
	 * 
	 * @return
	 */
	public static Singleton getInstance() {
		if (mInstance == null) {
			synchronized (Singleton.class) {
				if (mInstance == null) {
					mInstance = new Singleton();
				}
			}
		}
		return mInstance;
	}
	
	/**
	 * 方式三 : 饿汉模式在第一次加载SingletonHolder时初始化一次mOnlyInstance对象, 保证唯一性, 也延迟了单例的实例化, 如果该单例比较耗资源可以使用这种模式.
	public static Singleton getInstanceFromHolder() {
		return SingletonHolder.mOnlyInstance;
	}
	/**
	 * 静态内部类
	 * @author mrsimple
	 */
	private static class SingletonHolder {
		private static final Singleton mOnlyInstance = new Singleton();
	}

	/**
	 *  方式四 : 枚举单例, 线程安全
	 * @author mrsimple
	 */
	enum SingletonEnum {
		INSTANCE;
		public void doSomething() {
			System.out.println("do sth.");
		}
	}

	/**
	 * 方式五 : 注册到容器, 根据key获取对象.一般都会有多种相同属性类型的对象会注册到一个map中
	 * instance容器
	 */
	private static Map<string singleton=""> objMap = new HashMap<string singleton="">();
	/**
	 * 注册对象到map中
	 * @param key
	 * @param instance
	 */
	public static void registerService(String key, Singleton instance) {
		if (!objMap.containsKey(key) ) {
			objMap.put(key, instance) ;
		}
	}
	
	/**
	 * 根据key获取对象
	 * @param key
	 * @return
	 */
	public static Singleton getService(String key) {
		return objMap.get(key) ;
	}

```

### 桥接模式：

##### 模式的定义

将抽象部分与实现部分分离，使它们都可以独立的变化。

##### 模式的使用场景

- 如果一个系统需要在构件的抽象化角色和具体化角色之间添加更多的灵活性，避免在两个层次之间建立静态的联系。
- 设计要求实现化角色的任何改变不应当影响客户端，或者实现化角色的改变对客户端是完全透明的。
- 需要跨越多个平台的图形和窗口系统上。
- 一个类存在两个独立变化的维度，且两个维度都需要进行扩展。

##### 角色介绍

- 抽象化(Abstraction)角色：抽象化给出的定义，并保存一个对实现化对象的引用。 修正抽象化(Refined Abstraction)角色：扩展抽象化角色，改变和修正父类对抽象化的定义。
- 实现化(Implementor)角色：这个角色给出实现化角色的接口，但不给出具体的实现。必须指出的是，这个接 口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。
- 具体实现化(ConcreteImplementor)角色：这个角色给出实现化角色接口的具体实现。




**外观模式和中介模式区别**：

外观是对外的，每个接口是确定子系统的调用，相当于外观模式把一个系统所有的功能打包好了，提供一些接口给外界来使用这个系统的功能；中介是针对模块内部，侧重各个系统之间的互相调度，是不确定的子系统调用

**抽象工厂和工厂的区别**：

